// ДВУМЕРНЫЕ МАССИВЫ

// Двумерный массив НЕ РАВНО массив массивов. Потому что в двумерном массиве все элементы должны быть 
// одинакового размера (одинаковое количество вложенных элементов). Т.е. если двумерный массив задан как массив из 
// 3 строк и 5 столбцов. То не может какая-то из этих строк содержать количество элементов, отличное от 5.
// А массив массивов - это зубчатый массив (посмотреть что это)

int[,] matrix =
{
    {1, 5, 4, 8, 7},
    {2, 2, 7, 5, 1},
    {1, 5, 7, 2, 4}
};

System.Console.WriteLine(matrix.Length); // покажет 15 (т.е. 3 строки по 5 элементов)
System.Console.WriteLine(matrix.GetLength(0)); // покажет 3 (количество строк)
System.Console.WriteLine(matrix.GetLength(1)); // покажет 5 (количество столбцов)

// метод GetLength() в качестве аргументов принимает измерение. 0 - строки, 1 - столбцы
// для двумерного массива - 2 измерения, для 3-мерного было бы 3.
// НО при этом GetLength() это метод и требует время на свой вызов, т.е. если в цикле много 
// итераций и вызывать его при каждой for(int i = 0; i < GetLength(0); i++), то не оптимально.
// Поэтому лучше определить переменную перед циклом (см. задачу ниже)

// int[,] tempMatrix = new int[rows, cols];

// int numRow = tempMatrix.GetLength(0);
// int numColumn = tempMatrix.GetLength(1);
// for (int i = 0; i < numRow; i++)
// {
//     for (int j = 0; j < numColumn; j++)
//     {

//     }
// }

// объявление двумерного массива
int[,] matr = new int[10, 5];
int[,,,] matr = new[10, 5, 8, 2]; // четырехмерный массив

// трехмерный массив выглядел бы следующим образом

int[,,] matrix =
{
    {
        {1, 5, 4, 8, 7},
        {2, 2, 7, 5, 1},
        {1, 5, 7, 2, 4}
    },
    {
        {1, 5, 4, 8, 7},
        {2, 2, 7, 5, 1},
        {1, 5, 7, 2, 4}
    }
};

// Стандартная база для решения задач по двумерным массивам

void Main()
{
    int rowCount = ReadInt("Введите количество строк двумерного массива: ");
    int colCount = ReadInt("Введите количество столбцов двумерного массива: ");

    int[,] matrix = GenerateMatrix(rowCount, colCount, -99, 99);
    PrintMatrix(matrix);
}

void PrintMatrix(int[,] matrixForPrint)
{
    for (int i = 0; i < matrixForPrint.GetLength(0); i++)
    {
        for (int j = 0; j < matrixForPrint.GetLength(1); j++)
        {
            // 
            System.Console.Write(matrixForPrint[i, j] + "\t");
        }
        System.Console.WriteLine();
    }

    System.Console.WriteLine();
}

int[,] GenerateMatrix(int rows, int cols, int minValue, int maxValue)
{
    int[,] tempMatrix = new int[rows, cols];
    Random rand = new Random();

    for (int i = 0; i < tempMatrix.GetLength(0); i++)
    {
        for (int j = 0; j < tempMatrix.GetLength(1); j++)
        {
            tempMatrix[i, j] = rand.Next(minValue, maxValue + 1);
        }
    }

    return tempMatrix;
}

int ReadInt(string msg)
{
    System.Console.Write(msg);
    return Convert.ToInt32(Console.ReadLine());
}

Main();

// ЗНАЧИМЫЕ И ССЫЛОЧНЫЕ ТИПЫ ДАННЫХ
// Для хранения данных в оперативной памяти есть 2 области: Стэк и Куча. 
// Стэк - меньше по объему, в  него быстрее поместить и быстрее достать. 
// Куча - наоборот большая, но данные записываются и извлекаются медленнее
// В Стеке хранятся значимые типы данных (int, bool, double), а в Куче - ссылочные
// 
// ЗНАЧИМЫЙ ТИП ДАННЫХ
// Значимым тип данных называется потому, что когда мы передаем его в функцию, 
// то передаем не переменную, а значение этой переменной. В результате в функции
// образуется как бы дубликат переменной

void Main()
{
    int a = 7;
    F(a);
    System.Console.WriteLine(a);  // 7
}

void F(int a)
{
    a += 10;
}

// Т.е. передаем в фукнцию F переменную а, к ней добавляется 10, но после выполнения функции
// объявленная в ней переменная исчезает (т.к. она существует только в пределах того метода/цикла, который
// ее вызвал, а у нас void метод, т.е. не возвращает значение). Значимые переменные существуют В КОНТЕКСТЕ 
// метода/функции и т.п. 
// В итоге в методе Main после выполнения функции F значение переменной а все равно остается старым (7)

// ССЫЛОЧНЫЙ ТИП ДАННЫХ - ссылка на данные хранится в Стеке, а сами данные хранятся в Куче (string, двумерные массивы, Random)

void Main()
{
    int[] a = { 7 };
    F(a);
    System.Console.WriteLine(a[0]); // 17
}

void F(int[] a)
{
    a[0] += 10;
}

// В этом случае в функцию передается ссылка, создается дубликат ссылки, через обращение к которой
// изменяются сами данные, которые в Куче. По завершении функции ссылка стирается, но данные остаются
// модифицированными

// // как понять ссылочный или значимый тип данных?
// - если при наведении курсора на переменную видим в подсказке struct - значимый тип данных
// - если при наведении курсора на переменную видим какой-то class в подсказке - ссылочный тип

// Другой пример для ссылочного типа данных:
int[] a = { 1, 4, 6, 2, 8 };
int[] b = a;

b[0] = 999;

System.Console.WriteLine(string.Join(", ", a)); // 999, 4, 6, 2, 8
System.Console.WriteLine(string.Join(", ", b)); // 999, 4, 6, 2, 8

// Данные поменялись в обоих массивах, потому что int[] b = a; продублировали ссылку на массив,
// а не сам массив. Т.е. обе ссылки ведут к одним и тем же данным и меняют их. 


// Чтобы копировать ДАННЫЕ, а НЕ ссылку, можно использовать поэлементное копирование
int[] a = { 1, 4, 6, 2, 8 };
int[] b = new int[a.Length];

for (int i = 0; i < a.Length; i++)
    b[i] = a[i]

b[0] = 999;

System.Console.WriteLine(string.Join(", ", a)); // 1, 4, 6, 2, 8
System.Console.WriteLine(string.Join(", ", b)); // 999, 4, 6, 2, 8

// !!! Либо это можно сделать через  ДИАПАЗОНЫ

int[] a = { 1, 4, 6, 2, 8 };
int[] b = a[..3]; // скопирует только элементы с индексами от 0 до 3 (не включая)

b[0] = 999;

System.Console.WriteLine(string.Join(", ", a)); // 1, 4, 6, 2, 8
System.Console.WriteLine(string.Join(", ", b)); // 999, 4, 6

int[] a = { 1, 4, 6, 2, 8 };
int[] b = a[3..]; // скопирует в новый массив только элементы с индексами от 3-го и до конца 
b[0] = 999;

System.Console.WriteLine(string.Join(", ", a)); // 1, 4, 6, 2, 8
System.Console.WriteLine(string.Join(", ", b)); // 999, 8

int[] a = { 1, 4, 6, 2, 8 };
int[] b = a[..]; // скопирует в новый массив все элементы массива а 
b[0] = 999;

System.Console.WriteLine(string.Join(", ", a)); // 1, 4, 6, 2, 8
System.Console.WriteLine(string.Join(", ", b)); // 999, 4, 6, 2, 8

// можно указывать границы int[] b = a[3..12];