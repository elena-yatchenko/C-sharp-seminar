в терминале:
команда dotnet - проверка, что dotnet встал (нет ошибок)
команда dotnet --version - проверка версии 

Ctrl + Ё - переходим/отрываем/закрываем терминал

Включить автосохранение файла, иначе программа не будет 
читать внесенные в код изменения, пока вручную не сохраним (Ctrl + S): 
Ctrl + Shift + P - выйдет строка, где пишем auto save - выходит fale: toggle auto save - 
на нее нажимаем

Если в терминале русские символы заменяются на ???:
В самой ОС Windows зайти в наcтройки - Время и язык - Язык - Административные языковые настройки - 
Изменить местоположение системы (Change system locate) - поставить галочку "Beta-версия. Использовать юникод UTF-8 для международной
поддержки" - после потребуется перезагрузить систему.

Отформатировать код в единый формат (без лишних пробелов, выравнивание): Shift + Alt + F
(или правая кнопка мыши - форматировать документ)

!!!  cw - автоматически подставляет System.Console.WriteLine();

Есть 3 типа численных данных: byte, int, long. Они отличаются
своим максимальным значением. Проверить какое именно максимальное значение
для каждого из этих типов можно введя команды:

System.Console.WriteLine(byte.MaxValue);
System.Console.WriteLine(int.MaxValue);
System.Console.WriteLine(long.MaxValue);

Получим значения
255
2147483647
9223372036854775807

Это нужно для оптимизации программы, чтобы правильно выделять количество памяти (если знаем, что 
будут числа 1 - 10, им не нужен int, можно обойтись byte)

Convert.ToInt32(Console.ReadLine()) - конвертер, который лучше использовать 
// вместо int.Parse. Он точно так же вызывает внутри себя метод int.Parse, 
// но при этом содержит встроенные проверки, чтобы не выходили ошибки, если 
// пользователь неправильно введет  данные или не введет ничего. 

// Convert.ToInt32() - конвертация в int
// Convert.ToInt16() - конвертация в byte
// Convert.ToInt64() - конвертация в long


Принудительное прерывание выполнения кода в терминале - Ctrl + C

!!! Операция конкатинации автоматически переводит все объекты к типу данных string
string str = 7 + "text" - получим переменную строкового типа. 


!!! Ctrl + / - сразу ставит двойной слэш // для быстрого комментирования 
(Слэш использовать тот, что справа от буквы Ю на клавиатуре, не другой).


!!! SWITCH-CASE
Может использоваться тогда, когда от пользователя ждем какое-то конкретное
действие (значение). Например, в играх используют, чтобы при нажатии на одну кнопку
кавиатуры персонаж делал одно действие, при нажатии на другую - иное, на третью - третьей
и так далее (считывание что нажато на клавиатуре - команда ReadKey())

switch(x)
{
    case 1:
        System.Console.WriteLine("Введено 1");
        break;
    case 2:
        System.Console.WriteLine("Введено 2");
        break;
    case 40:
        System.Console.WriteLine("Введено 40!!!!");
        break;
    default:
        System.Console.WriteLine("Ошибка!");
        break;
}

!!! Перемещение строчек кода вверх-вниз без "copy - paste"
Находясь на строке кода зажать клавишу Alt и перемещаться стрелочками вверх-вниз

!!! 
Принципы Объекто-ориентированного программирования в C#:
1 - Single Responsibility Principe -  Т.е. каждый метод отвечает за выполнение 
какого-то одного действия/функции/задачи

!!! Правила "правильного кода" в C#
- DRY - Don't Repeat Yourself - т.е. не повторять одни и те же части кода. Если заметили, что где-то 
в коде делаем Copy - Paste, значит надо остановиться и подумать, как можно избежать этого повторения, 
может быть создать какой-то метод.
- YAGNI - You aren't gonna need it - Вам это не понадобиться. 
Т.е. отказ от избыточной функциональности (той, в которой нет непосредственной надобности)
- KISS - Keep it simple, stupid - простота системы как основная ценность.
Т.е. принцип, запрещающий использовать больше сложных средств, чем это необходимо. 

!!!
В языке C# сначала принято определять метод Main (главный метод),
внутри которого уже вызываются все прочие методы. Прочие методы определяются после (ниже) метода Main

Например:

void Main()
{
    // string request = "Введите размер массива";
    // int arraySize = ReadInt(request);
    int arraySize = ReadInt("Введите размер массива: ");
    int[] array = GenerateArray(arraySize, 0, 10);
    PrintArray(array);
}

void PrintArray(int[] arrayForPrint)
{
    for (int i = 0; i < arrayForPrint.Length; i++)
        System.Console.Write(arrayForPrint[i] + " ");

    System.Console.WriteLine();
}

int[] GenerateArray(int size, int minValue, int maxValue)
{
    int[] tempArray = new int[size];
    Random rand = new Random();

    for (int i = 0; i < tempArray.Length; i++)
        tempArray[i] = rand.Next(minValue, maxValue);

    return tempArray;
}

int ReadInt(string msg)
{
    System.Console.Write(msg);
    return Convert.ToInt32(Console.ReadLine()); // 13
}

Main();

!!! Если не отображаются подсказки при вводе кода, можно попробовать решить это через Обозреватель решений
(смотреть семинар 5 по С#, начиная со времени 2.40.00, там этот вопрос обсуждается )

!!! ОСНОВЫ ПРОГРАММИРОВАНИЯ НА С#
https://metanit.com/sharp/tutorial/2.4.php

!!! Лайфках для оформления комментариев к методам
В Visual Studio написать перед методом /// и автоматически сгенерируется 
часть xml-документа. Здесь можно пояснить параметры, что возвращает метод, зачем он 
(см. конспект лекции 6, конец)

!!! РЕКУРСИЯ - функция, которая вызывает сама себя. Используется на практике редко. Основная сфера использования - 
если нужно обходить древовидные структуры (например, при парсинге сайта (структура HTML - древовидная), 
или обойти содержимое папки (с вложенными в ней). 
Важно! Использование рекурсии может забить стек и функция "вылетит" просто. Т.к. пока работает рекурсия, значения
ВСЕХ переменных сохраняются в стеке. Удаляются они только когда рекурсия заканчивется и закрываются все рекурсивные
функции. 
Отличие цикла - на каждой итерации цикла переменная отрабатывает (используется или выводится ее значение) 
и удаляется из стека, далее переход к следующему значению переменной. 

!!! RETURN может использваться сам по себе, ничего не возвращая. Т.е. его основная задача - экстренное завершение (прерывание)
функции. Т.е. может использоваться и для методов void. Просто помимо этого может и возвращать какое-то значение.

!!! Телеграм Артем Михеев (доп.лекции по C#, можно обращаться, отвечает) - @tbrcklz